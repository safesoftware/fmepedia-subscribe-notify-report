<!DOCTYPE html>
<html>
	<head>
		<title>FME Server Demo - Subscribe to Events</title>
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<meta charset="UTF-8">
		<script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?sensor=false&libraries=drawing"></script>
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
		<script src="http://cdn.jquerytools.org/1.2.6/all/jquery.tools.min.js"></script>
		<link rel="stylesheet" type="text/css" href="style.css" />
		<script type="text/javascript">
			/* The Google Maps Object */
			var map;

			/* The current overlay the user draws */
			var currentOverlay = null;

			/* The prompt message box */
			var promptOverlay;

			/* The success message box */
			var successOverlay;

			/* The buffer response stored as a polygon */
			var bufferShape = null;

			/**
			 * Called when the page first loads
			 */
			function initialize() {

				/* Start - JQuery Toole Form Setup */

				// validator. we use custom message layout with a CSS arrow
				$("#myform").validator({
					message : '<div><em/></div>',
					position : 'top center',
					offset : [-5, 177]
				});

				$(":date").dateinput({
					trigger : true,
					format : 'dd mmmm yyyy',
					min : -1
				})

				// use the same callback for two different events. possible with bind
				$(":date").bind("onShow onHide", function() {
					$(this).parent().toggleClass("active");
				});
				// when first date input is changed
				$(":date:first").data("dateinput").change(function() {

					// we use it's value for the seconds input min option
					$(":date:last").data("dateinput").setMin(this.getValue(), true);
				});
				// rangeinput with default configuration
				$(":range").rangeinput();

				//Warn the user wih a prompt
				promptOverlay = $("#prompt").overlay({

					// some mask tweaks suitable for modal dialogs
					mask : {
						color : '#ebecff',
						loadSpeed : 200,
						opacity : 0.9
					},
					closeOnClick : false,
					// load it immediately after the construction
					load : false
				});
				successOverlay = $("#completed").overlay({

					// some mask tweaks suitable for modal dialogs
					mask : {
						color : '#ebecff',
						loadSpeed : 200,
						opacity : 0.9
					},

					closeOnClick : false,
					// load it immediately after the construction
					load : false
				});

				/* Setup Google Maps Object */
				var myOptions = {
					center : new google.maps.LatLng(34.0, -50.0),
					zoom : 3,
					mapTypeId : google.maps.MapTypeId.ROADMAP
				};
				map = new google.maps.Map(document.getElementById('map_canvas'), myOptions);

				google.maps.event.addListenerOnce(map, 'idle', function() {

				});
				/* Setup drawing manager */
				var drawingManager = new google.maps.drawing.DrawingManager({
					drawingMode : null,
					drawingControl : true,
					drawingControlOptions : {
						position : google.maps.ControlPosition.TOP_CENTER,
						drawingModes : [google.maps.drawing.OverlayType.POLYGON, google.maps.drawing.OverlayType.MARKER, google.maps.drawing.OverlayType.POLYLINE]
					},
					polygonOptions : {
						strokeColor : "#FF0000",
						strokeOpacity : 0.8,
						strokeWeight : 2,
						fillColor : "#FF0000",
						fillOpacity : 0.35
					}
				});

				drawingManager.setMap(map);

				/**
				 * Drawing listeners.
				 * Called when the user draws a shape
				 */
				function drawingListener(inFeature, type) {

					//Clear the previous overlays
					if(currentOverlay) {
						currentOverlay.geom.setMap(null);
						if(bufferShape) {
							bufferShape.setMap(null);
						}
					}

					//Reset the drawing manager
					drawingManager.setDrawingMode(null);

					//Set current object to the current map geom
					currentOverlay = {
						"type" : type,
						"geom" : inFeature
					};

				}

				/* Setup drawing listeners for each drawing object */
				google.maps.event.addListener(drawingManager, 'polygoncomplete', function(polygon) {
					drawingListener(polygon, 'polygon');
					streamBufferToMap(generateWktStr());
				});

				google.maps.event.addListener(drawingManager, 'markercomplete', function(point) {
					drawingListener(point, 'point');
					streamBufferToMap(generateWktStr());
				});

				google.maps.event.addListener(drawingManager, 'polylinecomplete', function(polyline) {
					drawingListener(polyline, 'polyline');
					streamBufferToMap(generateWktStr());
				});
			}

			/**
			 * Called when the user clicks the submit button on the form.
			 */
			function generateRequest() {

				// If there is no overlay currently on the map
				if(currentOverlay === null) {
					$("#prompt").overlay().load();

				} else {
					var url = 'http://localhost/fmerest/notifier/topics/EMSSubscribe/publish?token=186d5ab1d596eb9286cc01d0f74a3e9408abbc65';
					/* Create the JSON object */
					var jsonObj = { };
					jsonObj["wkt"] = generateWktStr();
					jsonObj["email"] = $("#txt_email").val();
					jsonObj["twitter"] = $("#txt_twitter").val();
					jsonObj["startdate"] = $(":date:first").data("dateinput").getValue();
					jsonObj["enddate"] = $(":date:last").data("dateinput").getValue();
					jsonObj["radius"] = $("#eventRadius").val();
					jsonObj["area_type"] = $('#notification_area option:selected').val();
					var jsonStr = JSON.stringify(jsonObj);

					/*
					 Commonly available on the web, this function was taken from:
					 http://ajaxpatterns.org/XMLHttpRequest_Call
					 */
					function createXMLHttpRequest() {
						try {
							return new XMLHttpRequest();
						} catch (e) {
						}
						try {
							return new ActiveXObject("Msxml2.XMLHTTP");
						} catch (e) {
						}
						alert("XMLHttpRequest not supported");
						return null;
					}

					/*
					 Display the result when complete
					 */
					function onResponse() {
						// 4 indicates a result is ready
						if(xhReq.readyState != 4) {

							return;
						}
						// Get the response and display it
						$("#completed").overlay().load();
						return;
					}

					var xhReq = createXMLHttpRequest();

					xhReq.open('POST', url, true);
					xhReq.onreadystatechange = onResponse;
					xhReq.send('"' + jsonStr + '"');

				}
			}

			/**
			 *
			 */
			function generateWktStr() {

				var wktStr = '';

				/* Create the WKT string. A different string for each GEOM type. */
				switch(currentOverlay.type) {
					case 'point':
						var gLatLng = currentOverlay.geom.getPosition();
						wktStr = 'POINT (' + gLatLng.lng() + ' ' + gLatLng.lat() + ')';

						break;

					case 'polygon':
						var gglePolyArray = currentOverlay.geom.getPath();
						gglePolyArray.forEach(function(item, index) {
							if(index === (gglePolyArray.length - 1)) {
								wktStr = wktStr + item.lng() + ' ' + item.lat();
							} else {
								wktStr = wktStr + item.lng() + ' ' + item.lat() + ', ';
							}

						});
						wktStr = 'POLYGON ((' + wktStr + '))';
						break;

					case 'polyline':
						var gglePolyArray = currentOverlay.geom.getPath();
						gglePolyArray.forEach(function(item, index) {
							if(index === (gglePolyArray.length - 1)) {
								wktStr = wktStr + item.lng() + ' ' + item.lat();
							} else {
								wktStr = wktStr + item.lng() + ' ' + item.lat() + ', ';
							}

						});
						wktStr = 'LINESTRING (' + wktStr + ')';
						break;
				}

				return wktStr;
			}

			/**
			 * Calls the data streaming service which draws the buffer on the map
			 * @inGeomString he WKT geometry string
			 */
			function streamBufferToMap(inGeomString) {

				/**
				 * Called when the POST is successful
				 * @inPolygonString The GeoJSON returned from the data streaming service
				 */
				function addBufferPolygonToMap(inPolygonString) {
					//Extract response and load into array
					var startPoint = inPolygonString.lastIndexOf("(") + 1;
					var endPoint = inPolygonString.indexOf(")")

					var trimmedStr = inPolygonString.substr(startPoint, (endPoint - startPoint));
					var arrayPoints = trimmedStr.split(",");
					var arrayLatLng = [];

					for(var i = arrayPoints.length - 1; i >= 0; i--) {

						var arrayCoords = arrayPoints[i].split(" ");
						arrayLatLng.push(new google.maps.LatLng(arrayCoords[1], arrayCoords[0]));

					}
					//Clear the previosu buffer
					try {
						bufferShape.setMap(null);
					} catch (e) {

					}

					/* Add the shape to the map */
					bufferShape = new google.maps.Polygon({
						paths : arrayLatLng,
						strokeColor : "#FF0000",
						strokeOpacity : 0.8,
						strokeWeight : 2,
						fillColor : "#FF0000",
						fillOpacity : 0.35
					});
					bufferShape.setMap(map);

				};

				/*
				 Commonly available on the web, this function was taken from:
				 http://ajaxpatterns.org/XMLHttpRequest_Call
				 */
				function createXMLHttpRequest() {
					try {
						return new XMLHttpRequest();
					} catch (e) {
					}
					try {
						return new ActiveXObject("Msxml2.XMLHTTP");
					} catch (e) {
					}
					alert("XMLHttpRequest not supported");
					return null;
				}

				/*
				 Display the result when complete
				 */
				function onResponse() {
					// 4 indicates a result is ready
					if(xhReq.readyState != 4)
						return;
					// Get the response and display it
					addBufferPolygonToMap(xhReq.responseText);

					return;
				}

				/*
				 Create the XMLHttpRequest object
				 */
				var xhReq = createXMLHttpRequest();
				// Request Variables
				pHostName = "localhost"
				pUrlBase = "http://" + pHostName + "/fmedatastreaming/EEMS/report_web_form_bufferer.fmw?tm_priority=50&bufferamount=" + $("#eventRadius").val()
				pHttpMethod = "POST"
				// Create REST call
				params = inGeomString;

				// Send request
				xhReq.open(pHttpMethod, pUrlBase, true);
				// xhReq.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
				xhReq.onreadystatechange = onResponse;
				xhReq.send(params);
			}


			google.maps.event.addDomListener(window, 'load', initialize);

		</script>
	</head>
	<body>
		<div class="modal" id="prompt">
			<h2>Define a Subscripton Area</h2>
			<p>
				Use the polygon draw tool on the top of the map to define a subscriptin area.
			</p>
		</div>
		<div class="modal" id="completed">
			<h2>Success</h2>
			<p>
				You have successfully subscribed to receive events in the area you defined.
			</p>
		</div>
		<!-- overlay trigger element -->
		<form class="rounded" id="myform" onSubmit="return false;" >
			<fieldset>
				<legend>
					1. Contact information
				</legend>
				<p>
					<label>Email</label>
					<input id="txt_email" type="email" required="required" class="invalid" />
				</p>
				<p>
					<label>Twitter (i.e. @SafeSoftware)</label>
					<input id="txt_twitter" type="text" />
				</p>
				<legend>
					2. Subscription Period
				</legend>
				<p>
					<div id="notificationDates">
						<div>
							Start
							<br/>
							<input type="date" name="arrival" value="Today" />
						</div>
						<div>
							End
							<br />
							<input type="date" name="departure" data-value="7" value="After one week" />
						</div>
				</p>
				</div>
				</p>
				<legend>
					3. Define Notification Area
				</legend>
				<p>
					<label>Buffer Radius (m)</label>
					<input type="text" required="required" value="0" id="eventRadius" />
				</p>
				<p>
					<label>Notifcation Area </label>
					<select id="notification_area">
						<option value="inside">Notify when event occurs INSIDE defined area.</option>
						<option value="outside">Notify when event occurs OUTSIDE defined area.</option>
					</select>
				</p>
			</fieldset>
			<p class="high">
				<button class="rounded" onClick="generateRequest()">
					Submit
				</button>
			</p>
		</form>
		<div id="map_canvas"></div>
	</body>
</html>
